/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `ReportStatus` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model ReportStatus
 *
 */
export type ReportStatusModel =
	runtime.Types.Result.DefaultSelection<Prisma.$ReportStatusPayload>;

export type AggregateReportStatus = {
	_count: ReportStatusCountAggregateOutputType | null;
	_avg: ReportStatusAvgAggregateOutputType | null;
	_sum: ReportStatusSumAggregateOutputType | null;
	_min: ReportStatusMinAggregateOutputType | null;
	_max: ReportStatusMaxAggregateOutputType | null;
};

export type ReportStatusAvgAggregateOutputType = {
	id: number | null;
};

export type ReportStatusSumAggregateOutputType = {
	id: number | null;
};

export type ReportStatusMinAggregateOutputType = {
	id: number | null;
	statusCode: string | null;
	label: string | null;
	badgeColor: string | null;
};

export type ReportStatusMaxAggregateOutputType = {
	id: number | null;
	statusCode: string | null;
	label: string | null;
	badgeColor: string | null;
};

export type ReportStatusCountAggregateOutputType = {
	id: number;
	statusCode: number;
	label: number;
	badgeColor: number;
	_all: number;
};

export type ReportStatusAvgAggregateInputType = {
	id?: true;
};

export type ReportStatusSumAggregateInputType = {
	id?: true;
};

export type ReportStatusMinAggregateInputType = {
	id?: true;
	statusCode?: true;
	label?: true;
	badgeColor?: true;
};

export type ReportStatusMaxAggregateInputType = {
	id?: true;
	statusCode?: true;
	label?: true;
	badgeColor?: true;
};

export type ReportStatusCountAggregateInputType = {
	id?: true;
	statusCode?: true;
	label?: true;
	badgeColor?: true;
	_all?: true;
};

export type ReportStatusAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which ReportStatus to aggregate.
	 */
	where?: Prisma.ReportStatusWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of ReportStatuses to fetch.
	 */
	orderBy?:
		| Prisma.ReportStatusOrderByWithRelationInput
		| Prisma.ReportStatusOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.ReportStatusWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` ReportStatuses from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` ReportStatuses.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned ReportStatuses
	 **/
	_count?: true | ReportStatusCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: ReportStatusAvgAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: ReportStatusSumAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: ReportStatusMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: ReportStatusMaxAggregateInputType;
};

export type GetReportStatusAggregateType<T extends ReportStatusAggregateArgs> =
	{
		[P in keyof T & keyof AggregateReportStatus]: P extends "_count" | "count"
			? T[P] extends true
				? number
				: Prisma.GetScalarType<T[P], AggregateReportStatus[P]>
			: Prisma.GetScalarType<T[P], AggregateReportStatus[P]>;
	};

export type ReportStatusGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.ReportStatusWhereInput;
	orderBy?:
		| Prisma.ReportStatusOrderByWithAggregationInput
		| Prisma.ReportStatusOrderByWithAggregationInput[];
	by: Prisma.ReportStatusScalarFieldEnum[] | Prisma.ReportStatusScalarFieldEnum;
	having?: Prisma.ReportStatusScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: ReportStatusCountAggregateInputType | true;
	_avg?: ReportStatusAvgAggregateInputType;
	_sum?: ReportStatusSumAggregateInputType;
	_min?: ReportStatusMinAggregateInputType;
	_max?: ReportStatusMaxAggregateInputType;
};

export type ReportStatusGroupByOutputType = {
	id: number;
	statusCode: string;
	label: string;
	badgeColor: string | null;
	_count: ReportStatusCountAggregateOutputType | null;
	_avg: ReportStatusAvgAggregateOutputType | null;
	_sum: ReportStatusSumAggregateOutputType | null;
	_min: ReportStatusMinAggregateOutputType | null;
	_max: ReportStatusMaxAggregateOutputType | null;
};

type GetReportStatusGroupByPayload<T extends ReportStatusGroupByArgs> =
	Prisma.PrismaPromise<
		Array<
			Prisma.PickEnumerable<ReportStatusGroupByOutputType, T["by"]> & {
				[P in keyof T & keyof ReportStatusGroupByOutputType]: P extends "_count"
					? T[P] extends boolean
						? number
						: Prisma.GetScalarType<T[P], ReportStatusGroupByOutputType[P]>
					: Prisma.GetScalarType<T[P], ReportStatusGroupByOutputType[P]>;
			}
		>
	>;

export type ReportStatusWhereInput = {
	AND?: Prisma.ReportStatusWhereInput | Prisma.ReportStatusWhereInput[];
	OR?: Prisma.ReportStatusWhereInput[];
	NOT?: Prisma.ReportStatusWhereInput | Prisma.ReportStatusWhereInput[];
	id?: Prisma.IntFilter<"ReportStatus"> | number;
	statusCode?: Prisma.StringFilter<"ReportStatus"> | string;
	label?: Prisma.StringFilter<"ReportStatus"> | string;
	badgeColor?: Prisma.StringNullableFilter<"ReportStatus"> | string | null;
	reports?: Prisma.ReportListRelationFilter;
};

export type ReportStatusOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	statusCode?: Prisma.SortOrder;
	label?: Prisma.SortOrder;
	badgeColor?: Prisma.SortOrderInput | Prisma.SortOrder;
	reports?: Prisma.ReportOrderByRelationAggregateInput;
};

export type ReportStatusWhereUniqueInput = Prisma.AtLeast<
	{
		id?: number;
		statusCode?: string;
		AND?: Prisma.ReportStatusWhereInput | Prisma.ReportStatusWhereInput[];
		OR?: Prisma.ReportStatusWhereInput[];
		NOT?: Prisma.ReportStatusWhereInput | Prisma.ReportStatusWhereInput[];
		label?: Prisma.StringFilter<"ReportStatus"> | string;
		badgeColor?: Prisma.StringNullableFilter<"ReportStatus"> | string | null;
		reports?: Prisma.ReportListRelationFilter;
	},
	"id" | "statusCode"
>;

export type ReportStatusOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	statusCode?: Prisma.SortOrder;
	label?: Prisma.SortOrder;
	badgeColor?: Prisma.SortOrderInput | Prisma.SortOrder;
	_count?: Prisma.ReportStatusCountOrderByAggregateInput;
	_avg?: Prisma.ReportStatusAvgOrderByAggregateInput;
	_max?: Prisma.ReportStatusMaxOrderByAggregateInput;
	_min?: Prisma.ReportStatusMinOrderByAggregateInput;
	_sum?: Prisma.ReportStatusSumOrderByAggregateInput;
};

export type ReportStatusScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.ReportStatusScalarWhereWithAggregatesInput
		| Prisma.ReportStatusScalarWhereWithAggregatesInput[];
	OR?: Prisma.ReportStatusScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.ReportStatusScalarWhereWithAggregatesInput
		| Prisma.ReportStatusScalarWhereWithAggregatesInput[];
	id?: Prisma.IntWithAggregatesFilter<"ReportStatus"> | number;
	statusCode?: Prisma.StringWithAggregatesFilter<"ReportStatus"> | string;
	label?: Prisma.StringWithAggregatesFilter<"ReportStatus"> | string;
	badgeColor?:
		| Prisma.StringNullableWithAggregatesFilter<"ReportStatus">
		| string
		| null;
};

export type ReportStatusCreateInput = {
	statusCode: string;
	label: string;
	badgeColor?: string | null;
	reports?: Prisma.ReportCreateNestedManyWithoutStatusInput;
};

export type ReportStatusUncheckedCreateInput = {
	id?: number;
	statusCode: string;
	label: string;
	badgeColor?: string | null;
	reports?: Prisma.ReportUncheckedCreateNestedManyWithoutStatusInput;
};

export type ReportStatusUpdateInput = {
	statusCode?: Prisma.StringFieldUpdateOperationsInput | string;
	label?: Prisma.StringFieldUpdateOperationsInput | string;
	badgeColor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	reports?: Prisma.ReportUpdateManyWithoutStatusNestedInput;
};

export type ReportStatusUncheckedUpdateInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	statusCode?: Prisma.StringFieldUpdateOperationsInput | string;
	label?: Prisma.StringFieldUpdateOperationsInput | string;
	badgeColor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	reports?: Prisma.ReportUncheckedUpdateManyWithoutStatusNestedInput;
};

export type ReportStatusCreateManyInput = {
	id?: number;
	statusCode: string;
	label: string;
	badgeColor?: string | null;
};

export type ReportStatusUpdateManyMutationInput = {
	statusCode?: Prisma.StringFieldUpdateOperationsInput | string;
	label?: Prisma.StringFieldUpdateOperationsInput | string;
	badgeColor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
};

export type ReportStatusUncheckedUpdateManyInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	statusCode?: Prisma.StringFieldUpdateOperationsInput | string;
	label?: Prisma.StringFieldUpdateOperationsInput | string;
	badgeColor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
};

export type ReportStatusCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	statusCode?: Prisma.SortOrder;
	label?: Prisma.SortOrder;
	badgeColor?: Prisma.SortOrder;
};

export type ReportStatusAvgOrderByAggregateInput = {
	id?: Prisma.SortOrder;
};

export type ReportStatusMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	statusCode?: Prisma.SortOrder;
	label?: Prisma.SortOrder;
	badgeColor?: Prisma.SortOrder;
};

export type ReportStatusMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	statusCode?: Prisma.SortOrder;
	label?: Prisma.SortOrder;
	badgeColor?: Prisma.SortOrder;
};

export type ReportStatusSumOrderByAggregateInput = {
	id?: Prisma.SortOrder;
};

export type ReportStatusNullableScalarRelationFilter = {
	is?: Prisma.ReportStatusWhereInput | null;
	isNot?: Prisma.ReportStatusWhereInput | null;
};

export type ReportStatusCreateNestedOneWithoutReportsInput = {
	create?: Prisma.XOR<
		Prisma.ReportStatusCreateWithoutReportsInput,
		Prisma.ReportStatusUncheckedCreateWithoutReportsInput
	>;
	connectOrCreate?: Prisma.ReportStatusCreateOrConnectWithoutReportsInput;
	connect?: Prisma.ReportStatusWhereUniqueInput;
};

export type ReportStatusUpdateOneWithoutReportsNestedInput = {
	create?: Prisma.XOR<
		Prisma.ReportStatusCreateWithoutReportsInput,
		Prisma.ReportStatusUncheckedCreateWithoutReportsInput
	>;
	connectOrCreate?: Prisma.ReportStatusCreateOrConnectWithoutReportsInput;
	upsert?: Prisma.ReportStatusUpsertWithoutReportsInput;
	disconnect?: Prisma.ReportStatusWhereInput | boolean;
	delete?: Prisma.ReportStatusWhereInput | boolean;
	connect?: Prisma.ReportStatusWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.ReportStatusUpdateToOneWithWhereWithoutReportsInput,
			Prisma.ReportStatusUpdateWithoutReportsInput
		>,
		Prisma.ReportStatusUncheckedUpdateWithoutReportsInput
	>;
};

export type ReportStatusCreateWithoutReportsInput = {
	statusCode: string;
	label: string;
	badgeColor?: string | null;
};

export type ReportStatusUncheckedCreateWithoutReportsInput = {
	id?: number;
	statusCode: string;
	label: string;
	badgeColor?: string | null;
};

export type ReportStatusCreateOrConnectWithoutReportsInput = {
	where: Prisma.ReportStatusWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.ReportStatusCreateWithoutReportsInput,
		Prisma.ReportStatusUncheckedCreateWithoutReportsInput
	>;
};

export type ReportStatusUpsertWithoutReportsInput = {
	update: Prisma.XOR<
		Prisma.ReportStatusUpdateWithoutReportsInput,
		Prisma.ReportStatusUncheckedUpdateWithoutReportsInput
	>;
	create: Prisma.XOR<
		Prisma.ReportStatusCreateWithoutReportsInput,
		Prisma.ReportStatusUncheckedCreateWithoutReportsInput
	>;
	where?: Prisma.ReportStatusWhereInput;
};

export type ReportStatusUpdateToOneWithWhereWithoutReportsInput = {
	where?: Prisma.ReportStatusWhereInput;
	data: Prisma.XOR<
		Prisma.ReportStatusUpdateWithoutReportsInput,
		Prisma.ReportStatusUncheckedUpdateWithoutReportsInput
	>;
};

export type ReportStatusUpdateWithoutReportsInput = {
	statusCode?: Prisma.StringFieldUpdateOperationsInput | string;
	label?: Prisma.StringFieldUpdateOperationsInput | string;
	badgeColor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
};

export type ReportStatusUncheckedUpdateWithoutReportsInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	statusCode?: Prisma.StringFieldUpdateOperationsInput | string;
	label?: Prisma.StringFieldUpdateOperationsInput | string;
	badgeColor?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
};

/**
 * Count Type ReportStatusCountOutputType
 */

export type ReportStatusCountOutputType = {
	reports: number;
};

export type ReportStatusCountOutputTypeSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	reports?: boolean | ReportStatusCountOutputTypeCountReportsArgs;
};

/**
 * ReportStatusCountOutputType without action
 */
export type ReportStatusCountOutputTypeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatusCountOutputType
	 */
	select?: Prisma.ReportStatusCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * ReportStatusCountOutputType without action
 */
export type ReportStatusCountOutputTypeCountReportsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.ReportWhereInput;
};

export type ReportStatusSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		statusCode?: boolean;
		label?: boolean;
		badgeColor?: boolean;
		reports?: boolean | Prisma.ReportStatus$reportsArgs<ExtArgs>;
		_count?: boolean | Prisma.ReportStatusCountOutputTypeDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["reportStatus"]
>;

export type ReportStatusSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		statusCode?: boolean;
		label?: boolean;
		badgeColor?: boolean;
	},
	ExtArgs["result"]["reportStatus"]
>;

export type ReportStatusSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		statusCode?: boolean;
		label?: boolean;
		badgeColor?: boolean;
	},
	ExtArgs["result"]["reportStatus"]
>;

export type ReportStatusSelectScalar = {
	id?: boolean;
	statusCode?: boolean;
	label?: boolean;
	badgeColor?: boolean;
};

export type ReportStatusOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	"id" | "statusCode" | "label" | "badgeColor",
	ExtArgs["result"]["reportStatus"]
>;
export type ReportStatusInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	reports?: boolean | Prisma.ReportStatus$reportsArgs<ExtArgs>;
	_count?: boolean | Prisma.ReportStatusCountOutputTypeDefaultArgs<ExtArgs>;
};
export type ReportStatusIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {};
export type ReportStatusIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {};

export type $ReportStatusPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: "ReportStatus";
	objects: {
		reports: Prisma.$ReportPayload<ExtArgs>[];
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: number;
			statusCode: string;
			label: string;
			badgeColor: string | null;
		},
		ExtArgs["result"]["reportStatus"]
	>;
	composites: {};
};

export type ReportStatusGetPayload<
	S extends boolean | null | undefined | ReportStatusDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$ReportStatusPayload, S>;

export type ReportStatusCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<
	ReportStatusFindManyArgs,
	"select" | "include" | "distinct" | "omit"
> & {
	select?: ReportStatusCountAggregateInputType | true;
};

export interface ReportStatusDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>["model"]["ReportStatus"];
		meta: { name: "ReportStatus" };
	};
	/**
	 * Find zero or one ReportStatus that matches the filter.
	 * @param {ReportStatusFindUniqueArgs} args - Arguments to find a ReportStatus
	 * @example
	 * // Get one ReportStatus
	 * const reportStatus = await prisma.reportStatus.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends ReportStatusFindUniqueArgs>(
		args: Prisma.SelectSubset<T, ReportStatusFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__ReportStatusClient<
		runtime.Types.Result.GetResult<
			Prisma.$ReportStatusPayload<ExtArgs>,
			T,
			"findUnique",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one ReportStatus that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {ReportStatusFindUniqueOrThrowArgs} args - Arguments to find a ReportStatus
	 * @example
	 * // Get one ReportStatus
	 * const reportStatus = await prisma.reportStatus.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends ReportStatusFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, ReportStatusFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__ReportStatusClient<
		runtime.Types.Result.GetResult<
			Prisma.$ReportStatusPayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first ReportStatus that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ReportStatusFindFirstArgs} args - Arguments to find a ReportStatus
	 * @example
	 * // Get one ReportStatus
	 * const reportStatus = await prisma.reportStatus.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends ReportStatusFindFirstArgs>(
		args?: Prisma.SelectSubset<T, ReportStatusFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__ReportStatusClient<
		runtime.Types.Result.GetResult<
			Prisma.$ReportStatusPayload<ExtArgs>,
			T,
			"findFirst",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first ReportStatus that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ReportStatusFindFirstOrThrowArgs} args - Arguments to find a ReportStatus
	 * @example
	 * // Get one ReportStatus
	 * const reportStatus = await prisma.reportStatus.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends ReportStatusFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, ReportStatusFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__ReportStatusClient<
		runtime.Types.Result.GetResult<
			Prisma.$ReportStatusPayload<ExtArgs>,
			T,
			"findFirstOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more ReportStatuses that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ReportStatusFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all ReportStatuses
	 * const reportStatuses = await prisma.reportStatus.findMany()
	 *
	 * // Get first 10 ReportStatuses
	 * const reportStatuses = await prisma.reportStatus.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const reportStatusWithIdOnly = await prisma.reportStatus.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends ReportStatusFindManyArgs>(
		args?: Prisma.SelectSubset<T, ReportStatusFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$ReportStatusPayload<ExtArgs>,
			T,
			"findMany",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a ReportStatus.
	 * @param {ReportStatusCreateArgs} args - Arguments to create a ReportStatus.
	 * @example
	 * // Create one ReportStatus
	 * const ReportStatus = await prisma.reportStatus.create({
	 *   data: {
	 *     // ... data to create a ReportStatus
	 *   }
	 * })
	 *
	 */
	create<T extends ReportStatusCreateArgs>(
		args: Prisma.SelectSubset<T, ReportStatusCreateArgs<ExtArgs>>,
	): Prisma.Prisma__ReportStatusClient<
		runtime.Types.Result.GetResult<
			Prisma.$ReportStatusPayload<ExtArgs>,
			T,
			"create",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many ReportStatuses.
	 * @param {ReportStatusCreateManyArgs} args - Arguments to create many ReportStatuses.
	 * @example
	 * // Create many ReportStatuses
	 * const reportStatus = await prisma.reportStatus.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends ReportStatusCreateManyArgs>(
		args?: Prisma.SelectSubset<T, ReportStatusCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many ReportStatuses and returns the data saved in the database.
	 * @param {ReportStatusCreateManyAndReturnArgs} args - Arguments to create many ReportStatuses.
	 * @example
	 * // Create many ReportStatuses
	 * const reportStatus = await prisma.reportStatus.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many ReportStatuses and only return the `id`
	 * const reportStatusWithIdOnly = await prisma.reportStatus.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends ReportStatusCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<T, ReportStatusCreateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$ReportStatusPayload<ExtArgs>,
			T,
			"createManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a ReportStatus.
	 * @param {ReportStatusDeleteArgs} args - Arguments to delete one ReportStatus.
	 * @example
	 * // Delete one ReportStatus
	 * const ReportStatus = await prisma.reportStatus.delete({
	 *   where: {
	 *     // ... filter to delete one ReportStatus
	 *   }
	 * })
	 *
	 */
	delete<T extends ReportStatusDeleteArgs>(
		args: Prisma.SelectSubset<T, ReportStatusDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__ReportStatusClient<
		runtime.Types.Result.GetResult<
			Prisma.$ReportStatusPayload<ExtArgs>,
			T,
			"delete",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one ReportStatus.
	 * @param {ReportStatusUpdateArgs} args - Arguments to update one ReportStatus.
	 * @example
	 * // Update one ReportStatus
	 * const reportStatus = await prisma.reportStatus.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends ReportStatusUpdateArgs>(
		args: Prisma.SelectSubset<T, ReportStatusUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__ReportStatusClient<
		runtime.Types.Result.GetResult<
			Prisma.$ReportStatusPayload<ExtArgs>,
			T,
			"update",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more ReportStatuses.
	 * @param {ReportStatusDeleteManyArgs} args - Arguments to filter ReportStatuses to delete.
	 * @example
	 * // Delete a few ReportStatuses
	 * const { count } = await prisma.reportStatus.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends ReportStatusDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, ReportStatusDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more ReportStatuses.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ReportStatusUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many ReportStatuses
	 * const reportStatus = await prisma.reportStatus.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends ReportStatusUpdateManyArgs>(
		args: Prisma.SelectSubset<T, ReportStatusUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more ReportStatuses and returns the data updated in the database.
	 * @param {ReportStatusUpdateManyAndReturnArgs} args - Arguments to update many ReportStatuses.
	 * @example
	 * // Update many ReportStatuses
	 * const reportStatus = await prisma.reportStatus.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more ReportStatuses and only return the `id`
	 * const reportStatusWithIdOnly = await prisma.reportStatus.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends ReportStatusUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<T, ReportStatusUpdateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$ReportStatusPayload<ExtArgs>,
			T,
			"updateManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one ReportStatus.
	 * @param {ReportStatusUpsertArgs} args - Arguments to update or create a ReportStatus.
	 * @example
	 * // Update or create a ReportStatus
	 * const reportStatus = await prisma.reportStatus.upsert({
	 *   create: {
	 *     // ... data to create a ReportStatus
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the ReportStatus we want to update
	 *   }
	 * })
	 */
	upsert<T extends ReportStatusUpsertArgs>(
		args: Prisma.SelectSubset<T, ReportStatusUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__ReportStatusClient<
		runtime.Types.Result.GetResult<
			Prisma.$ReportStatusPayload<ExtArgs>,
			T,
			"upsert",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of ReportStatuses.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ReportStatusCountArgs} args - Arguments to filter ReportStatuses to count.
	 * @example
	 * // Count the number of ReportStatuses
	 * const count = await prisma.reportStatus.count({
	 *   where: {
	 *     // ... the filter for the ReportStatuses we want to count
	 *   }
	 * })
	 **/
	count<T extends ReportStatusCountArgs>(
		args?: Prisma.Subset<T, ReportStatusCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<"select", any>
			? T["select"] extends true
				? number
				: Prisma.GetScalarType<
						T["select"],
						ReportStatusCountAggregateOutputType
					>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a ReportStatus.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ReportStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends ReportStatusAggregateArgs>(
		args: Prisma.Subset<T, ReportStatusAggregateArgs>,
	): Prisma.PrismaPromise<GetReportStatusAggregateType<T>>;

	/**
	 * Group by ReportStatus.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ReportStatusGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends ReportStatusGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<"skip", Prisma.Keys<T>>,
			Prisma.Extends<"take", Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: ReportStatusGroupByArgs["orderBy"] }
			: { orderBy?: ReportStatusGroupByArgs["orderBy"] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T["having"]>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										"Field ",
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: "take" extends Prisma.Keys<T>
					? "orderBy" extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: "skip" extends Prisma.Keys<T>
						? "orderBy" extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, ReportStatusGroupByArgs, OrderByArg> &
			InputErrors,
	): {} extends InputErrors
		? GetReportStatusGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the ReportStatus model
	 */
	readonly fields: ReportStatusFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for ReportStatus.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ReportStatusClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: "PrismaPromise";
	reports<T extends Prisma.ReportStatus$reportsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.ReportStatus$reportsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$ReportPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the ReportStatus model
 */
export interface ReportStatusFieldRefs {
	readonly id: Prisma.FieldRef<"ReportStatus", "Int">;
	readonly statusCode: Prisma.FieldRef<"ReportStatus", "String">;
	readonly label: Prisma.FieldRef<"ReportStatus", "String">;
	readonly badgeColor: Prisma.FieldRef<"ReportStatus", "String">;
}

// Custom InputTypes
/**
 * ReportStatus findUnique
 */
export type ReportStatusFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ReportStatusInclude<ExtArgs> | null;
	/**
	 * Filter, which ReportStatus to fetch.
	 */
	where: Prisma.ReportStatusWhereUniqueInput;
};

/**
 * ReportStatus findUniqueOrThrow
 */
export type ReportStatusFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ReportStatusInclude<ExtArgs> | null;
	/**
	 * Filter, which ReportStatus to fetch.
	 */
	where: Prisma.ReportStatusWhereUniqueInput;
};

/**
 * ReportStatus findFirst
 */
export type ReportStatusFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ReportStatusInclude<ExtArgs> | null;
	/**
	 * Filter, which ReportStatus to fetch.
	 */
	where?: Prisma.ReportStatusWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of ReportStatuses to fetch.
	 */
	orderBy?:
		| Prisma.ReportStatusOrderByWithRelationInput
		| Prisma.ReportStatusOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for ReportStatuses.
	 */
	cursor?: Prisma.ReportStatusWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` ReportStatuses from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` ReportStatuses.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of ReportStatuses.
	 */
	distinct?:
		| Prisma.ReportStatusScalarFieldEnum
		| Prisma.ReportStatusScalarFieldEnum[];
};

/**
 * ReportStatus findFirstOrThrow
 */
export type ReportStatusFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ReportStatusInclude<ExtArgs> | null;
	/**
	 * Filter, which ReportStatus to fetch.
	 */
	where?: Prisma.ReportStatusWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of ReportStatuses to fetch.
	 */
	orderBy?:
		| Prisma.ReportStatusOrderByWithRelationInput
		| Prisma.ReportStatusOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for ReportStatuses.
	 */
	cursor?: Prisma.ReportStatusWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` ReportStatuses from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` ReportStatuses.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of ReportStatuses.
	 */
	distinct?:
		| Prisma.ReportStatusScalarFieldEnum
		| Prisma.ReportStatusScalarFieldEnum[];
};

/**
 * ReportStatus findMany
 */
export type ReportStatusFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ReportStatusInclude<ExtArgs> | null;
	/**
	 * Filter, which ReportStatuses to fetch.
	 */
	where?: Prisma.ReportStatusWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of ReportStatuses to fetch.
	 */
	orderBy?:
		| Prisma.ReportStatusOrderByWithRelationInput
		| Prisma.ReportStatusOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing ReportStatuses.
	 */
	cursor?: Prisma.ReportStatusWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` ReportStatuses from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` ReportStatuses.
	 */
	skip?: number;
	distinct?:
		| Prisma.ReportStatusScalarFieldEnum
		| Prisma.ReportStatusScalarFieldEnum[];
};

/**
 * ReportStatus create
 */
export type ReportStatusCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ReportStatusInclude<ExtArgs> | null;
	/**
	 * The data needed to create a ReportStatus.
	 */
	data: Prisma.XOR<
		Prisma.ReportStatusCreateInput,
		Prisma.ReportStatusUncheckedCreateInput
	>;
};

/**
 * ReportStatus createMany
 */
export type ReportStatusCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many ReportStatuses.
	 */
	data:
		| Prisma.ReportStatusCreateManyInput
		| Prisma.ReportStatusCreateManyInput[];
	skipDuplicates?: boolean;
};

/**
 * ReportStatus createManyAndReturn
 */
export type ReportStatusCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * The data used to create many ReportStatuses.
	 */
	data:
		| Prisma.ReportStatusCreateManyInput
		| Prisma.ReportStatusCreateManyInput[];
	skipDuplicates?: boolean;
};

/**
 * ReportStatus update
 */
export type ReportStatusUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ReportStatusInclude<ExtArgs> | null;
	/**
	 * The data needed to update a ReportStatus.
	 */
	data: Prisma.XOR<
		Prisma.ReportStatusUpdateInput,
		Prisma.ReportStatusUncheckedUpdateInput
	>;
	/**
	 * Choose, which ReportStatus to update.
	 */
	where: Prisma.ReportStatusWhereUniqueInput;
};

/**
 * ReportStatus updateMany
 */
export type ReportStatusUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update ReportStatuses.
	 */
	data: Prisma.XOR<
		Prisma.ReportStatusUpdateManyMutationInput,
		Prisma.ReportStatusUncheckedUpdateManyInput
	>;
	/**
	 * Filter which ReportStatuses to update
	 */
	where?: Prisma.ReportStatusWhereInput;
	/**
	 * Limit how many ReportStatuses to update.
	 */
	limit?: number;
};

/**
 * ReportStatus updateManyAndReturn
 */
export type ReportStatusUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * The data used to update ReportStatuses.
	 */
	data: Prisma.XOR<
		Prisma.ReportStatusUpdateManyMutationInput,
		Prisma.ReportStatusUncheckedUpdateManyInput
	>;
	/**
	 * Filter which ReportStatuses to update
	 */
	where?: Prisma.ReportStatusWhereInput;
	/**
	 * Limit how many ReportStatuses to update.
	 */
	limit?: number;
};

/**
 * ReportStatus upsert
 */
export type ReportStatusUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ReportStatusInclude<ExtArgs> | null;
	/**
	 * The filter to search for the ReportStatus to update in case it exists.
	 */
	where: Prisma.ReportStatusWhereUniqueInput;
	/**
	 * In case the ReportStatus found by the `where` argument doesn't exist, create a new ReportStatus with this data.
	 */
	create: Prisma.XOR<
		Prisma.ReportStatusCreateInput,
		Prisma.ReportStatusUncheckedCreateInput
	>;
	/**
	 * In case the ReportStatus was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<
		Prisma.ReportStatusUpdateInput,
		Prisma.ReportStatusUncheckedUpdateInput
	>;
};

/**
 * ReportStatus delete
 */
export type ReportStatusDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ReportStatusInclude<ExtArgs> | null;
	/**
	 * Filter which ReportStatus to delete.
	 */
	where: Prisma.ReportStatusWhereUniqueInput;
};

/**
 * ReportStatus deleteMany
 */
export type ReportStatusDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which ReportStatuses to delete
	 */
	where?: Prisma.ReportStatusWhereInput;
	/**
	 * Limit how many ReportStatuses to delete.
	 */
	limit?: number;
};

/**
 * ReportStatus.reports
 */
export type ReportStatus$reportsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Report
	 */
	select?: Prisma.ReportSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Report
	 */
	omit?: Prisma.ReportOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ReportInclude<ExtArgs> | null;
	where?: Prisma.ReportWhereInput;
	orderBy?:
		| Prisma.ReportOrderByWithRelationInput
		| Prisma.ReportOrderByWithRelationInput[];
	cursor?: Prisma.ReportWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.ReportScalarFieldEnum | Prisma.ReportScalarFieldEnum[];
};

/**
 * ReportStatus without action
 */
export type ReportStatusDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ReportStatus
	 */
	select?: Prisma.ReportStatusSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ReportStatus
	 */
	omit?: Prisma.ReportStatusOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ReportStatusInclude<ExtArgs> | null;
};
